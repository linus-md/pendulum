import logging
import datetime

from sage.all import ideal

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def delta(qi, pi):
    """
    This function computes the linear differential operator given by polynomials
    qi and an applies it to the polynomial pi.

    Parameters
    ----------
    `qi` : list of polynomials
        List of polynomials that represent the linear differential operator.
    `pi` : polynomial

    Returns
    -------
    polynomial
    """
    vars = qi.parent().gens()
    return sum([pi[i] * qi.derivative(var) for i, var in enumerate(vars)])


def algorithm_ideal(qi, pi):
    """
    This function computes the minimal ideal generated by the polynomials pi 
    that is stable under delta(qi, pi). This function is an implementation of
    Algorithm 2 in the thesis.

    Parameters
    ----------
    `qi` : list of polynomials
        List of polynomials that represent the linear differential operator.
    `pi` : list of polynomials
        List of polynomials that represent the initial ideal.

    Returns
    -------
    Groebner basis of the minimal ideal generated by the polynomials `pi` that is
    stable under `delta(qi, pi)`.
    """
    I = ideal(qi)  
    i = 0
    logger.info('Algorithm 2 started')
    start_time = datetime.datetime.now()
    logger.info(f'Iteration {i} - {start_time}')

    while True:
        qi = [delta(qs, pi) for qs in qi]
        qi = [qs.reduce(I) for qs in qi]
    
        if any(qs != 0 for qs in qi):
            i += 1
            I = I + ideal(qi)
            current_time = datetime.datetime.now()
            time_delta = current_time - start_time
            
            logger.info(f'Iteration {i} - {time_delta} - {len(I.gens())}')
        else:
            # This gets computed eventhough we compute it for the reduction above...
            end_time = datetime.datetime.now()
            time_delta = end_time - start_time
            logger.info('Algorithm 0 ended at - {}'.format(time_delta))
            return ideal(I).groebner_basis()


def algorithm_gb(qi, pi):
    """
    This function computes the minimal ideal generated by the polynomials pi 
    that is stable under `delta(qi, pi). This function is an implementation of
    an adapted version of Algorithm 2 in the thesis. Instead of adding new 
    generators to the ideal, they are added to the new Gr√∂bner basis.

    Parameters
    ----------
    `qi` : list of polynomials
        List of polynomials that represent the linear differential operator.
    `pi` : list of polynomials
        List of polynomials that represent the initial ideal.

    Returns
    -------
    Groebner basis of the minimal ideal generated by the polynomials `pi` that is
    stable under `delta(qi, pi)`.
    """
    i = 0
    logger.info('Algorithm 2.1 started')
    start_time = datetime.datetime.now()
    last_time = start_time 
    logger.info(f'Iteration {i} - {start_time}')
    G = ideal(qi).groebner_basis()

    while True:
        qi = [delta(qs, pi) for qs in qi]
        qi = [qs.reduce(G) for qs in qi]


        if any(qs != 0 for qs in qi):
            i += 1
            current_time = datetime.datetime.now()
            time_delta = current_time - last_time
            last_time = current_time
            G = ideal(list(set(G + qi))).groebner_basis()
            logger.info(f'Iteration {i} - {time_delta} - {len(G)}')
        else:
            end_time = datetime.datetime.now()
            time_delta = end_time - start_time
            logger.info('Algorithm 1 ended in - {}'.format(time_delta))
            return G
